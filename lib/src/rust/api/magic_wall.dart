// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `IS_RUNNING`, `MAGIC_WALL_RULES`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `deref`, `deref`, `fmt`, `fmt`, `initialize`, `initialize`

/// 启动魔法墙引擎
Future<void> startMagicWall() =>
    RustLib.instance.api.crateApiMagicWallStartMagicWall();

/// 停止魔法墙引擎
Future<void> stopMagicWall() =>
    RustLib.instance.api.crateApiMagicWallStopMagicWall();

/// 添加规则
Future<void> addMagicWallRule({required MagicWallRule rule}) =>
    RustLib.instance.api.crateApiMagicWallAddMagicWallRule(rule: rule);

/// 删除规则
Future<void> removeMagicWallRule({required String ruleId}) =>
    RustLib.instance.api.crateApiMagicWallRemoveMagicWallRule(ruleId: ruleId);

/// 更新规则
Future<void> updateMagicWallRule({required MagicWallRule rule}) =>
    RustLib.instance.api.crateApiMagicWallUpdateMagicWallRule(rule: rule);

/// 获取魔法墙状态
Future<MagicWallStatus> getMagicWallStatus() =>
    RustLib.instance.api.crateApiMagicWallGetMagicWallStatus();

/// 创建默认规则示例
Future<List<MagicWallRule>> createDefaultMagicWallRules() =>
    RustLib.instance.api.crateApiMagicWallCreateDefaultMagicWallRules();

/// 魔法墙规则配置
class MagicWallRule {
  final String id;
  final String name;
  final bool enabled;
  final String action;
  final String protocol;
  final String direction;
  final String? appPath;
  final String? remoteIp;
  final String? localIp;
  final String? remotePort;
  final String? localPort;
  final String? description;
  final PlatformInt64? createdAt;

  const MagicWallRule({
    required this.id,
    required this.name,
    required this.enabled,
    required this.action,
    required this.protocol,
    required this.direction,
    this.appPath,
    this.remoteIp,
    this.localIp,
    this.remotePort,
    this.localPort,
    this.description,
    this.createdAt,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      enabled.hashCode ^
      action.hashCode ^
      protocol.hashCode ^
      direction.hashCode ^
      appPath.hashCode ^
      remoteIp.hashCode ^
      localIp.hashCode ^
      remotePort.hashCode ^
      localPort.hashCode ^
      description.hashCode ^
      createdAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MagicWallRule &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          enabled == other.enabled &&
          action == other.action &&
          protocol == other.protocol &&
          direction == other.direction &&
          appPath == other.appPath &&
          remoteIp == other.remoteIp &&
          localIp == other.localIp &&
          remotePort == other.remotePort &&
          localPort == other.localPort &&
          description == other.description &&
          createdAt == other.createdAt;
}

/// 魔法墙状态
class MagicWallStatus {
  final bool isRunning;
  final BigInt activeRules;
  final BigInt totalRules;

  const MagicWallStatus({
    required this.isRunning,
    required this.activeRules,
    required this.totalRules,
  });

  @override
  int get hashCode =>
      isRunning.hashCode ^ activeRules.hashCode ^ totalRules.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MagicWallStatus &&
          runtimeType == other.runtimeType &&
          isRunning == other.isRunning &&
          activeRules == other.activeRules &&
          totalRules == other.totalRules;
}
